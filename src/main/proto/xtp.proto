syntax = "proto3";

option java_multiple_files = true;
//option java_outer_classname = "BasicProto";

/*
    XTP(X Transfer Protocol)
    协议版本：0.13.1
    定义应用程序创建的服务端（或客户端）Socket称为“端”，对应的客户端（或服务端）为“对端”，应用自己这“端”为“本端”，
    发送协议消息的“端”为“发送端”，接收协议消息的“端”为“接收端”，一个“端”或“对端”既可以是“发送端”也可以是“接收端”。

    定义一条“流”包含一个“本端”的“生产者”和一个“对端”的“消费者”，
    以“生产者”发送Frame.message（以Header序列化）开始“流”的生命周期，
    以“生产者”发送一个Frame.end或以“消费者”发送一个Frame.cancel结束生命周期，
    生命周期未结束时，“消费者”可发送多次“拉取量”Frame.pull以期望得到“生产者”多次发送的有序的“流消息”Frame.message，
    “生产者”发送的“流消息”的总数必须小于等于“消费者”发送的“拉取量(Frame.pull)”总和。

    流生命周期举例：
    例一：
    message(Header)->
    <-pull
    message->
    message->
    <-pull
    message->
    end->

    例二:
    message(Header)->
    <-cancel

    分帧：
    当使用提供分帧方案的底层传输协议时（例如：WebSocket），
    将数据帧(下文定义的Frame)序列化成二进制数据后直接放入传输协议的消息（二进制数据字段/Payload Data）中。
    当使用无分帧方案的底层传输协议时（例如：TCP），在发送数据帧前增加24位有符号位且大于0的数字，符号位为0表示正数，
    之后紧跟序列化为二进制数据的数据帧(下文定义的Frame)
     0                   1                   2
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |0|                Frame Length                 |
    +-----------------------------------------------+
    |                XTP Frame          ...
    |
    +-----------------------------------------------+

    心跳：
    当使用TCP传输时，连接的一端应该定期(默认为20s)发送24位全0数据（表示一次Ping），以通知另一端自己还活着。
     0                   1                   2
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                   All 0                       |
    +-----------------------------------------------+
    其他传输协议使用自己的Ping/Pong方案。
 */
package xtp;

//数据帧，连接上的基础数据载体
message Frame {
    //流ID，表示此数据帧属于哪条流，0表示连接，0流只允许接收一个message（以Header序列化）
    int32 flow_id = 1;
    oneof type {
        //流的消息，表示发送端（生产者）发送了一个流消息
        //发送的消息的总数必须小于等于“拉取量(Frame.pull)”的总和
        bytes message = 2;
        //流的结束，表示发送端（生产者）结束发送流消息，流的命周期结束
        End end = 3;
        //拉取量，表示发送端（消费者）的可接收消息数的增量，大于0，用于“流消息”的流量控制
        //与ReactiveStream里的request语义相同
        int32 pull = 4;
        //取消流的原因，表示发送端（消费者）取消接收流消息，等待对端发送end后流的生命周期结束
        Error cancel = 5;
    }
}

//流头，表示发送端请求创建一条新流
message Header {
    //流标识，必须大于0，本端每开启新流值加1，可以与对端的新流ID相同，但它们是两个不同方向上的不同的流
    int32 flow_id = 1;
    //任意文本数据（可空）
    string text = 2;
    //任意二进制数据（可空）
    bytes data = 3;
}

//结束，流的生命周期结束
message End {
    //错误（可空），空时表示流成功结束
    Error error = 1;
}

//错误
message Error {
    //错误类名
    string type_name = 1;
    //错误消息（可空）
    string text_message = 2;
}